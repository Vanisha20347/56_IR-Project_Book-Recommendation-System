# -*- coding: utf-8 -*-
"""hybrid.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1uOyIpauJStEXHIv9gfNsx06I2CyCjzAh
"""

import itertools
import pandas as pd
import math
import nltk
import random
# import matplotlib.pyplot as plt
import numpy as np
import re
import pickle
from nltk.tokenize import RegexpTokenizer
from sklearn.model_selection import train_test_split
from sklearn.feature_extraction.text import TfidfVectorizer, CountVectorizer
from sklearn.metrics.pairwise import cosine_similarity
from sklearn.naive_bayes import MultinomialNB
from sklearn.metrics import accuracy_score, confusion_matrix, classification_report
from sklearn.pipeline import Pipeline
from nltk.classify.textcat import TextCat
import dask.dataframe as dd
import multiprocessing
import random
from scipy.sparse.linalg import cg

nltk.download('punkt')
nltk.download('crubadan')
nltk.download('stopwords')
tokenizer = RegexpTokenizer('\w+')

nltk.download('own-1.4')
nltk.download('wordnet')

from nltk.stem import WordNetLemmatizer
lemmatizer = WordNetLemmatizer()

from nltk.corpus import stopwords
stop_words = set(stopwords.words('english'))

# from google.colab import drive
# drive.mount('/content/drive', force_remount = True)

users = pd.read_csv("data/final_users.csv")
# print(users.head())

books = pd.read_csv("data/final_books.csv")
# print(books.head())

# Find number of NaN in each column
books.isna().sum()

books[["Publisher"]] = books[["Publisher"]].fillna("unknown")

# books.Language.unique()

html_pattern = re.compile('<[^>]*>')
def remove_html_tags(text):
    return re.sub(html_pattern, r'', text)

books.Description = books.Description.apply(remove_html_tags)
books.head()

text = list(books["Description"])
prepro_test = []

for i in text:

  s = ""
  i = i.lower()
  ans = tokenizer.tokenize(i)

  for j in ans:
    
    y = lemmatizer.lemmatize(j)

    if y not in stop_words:
      s = s + " " + y 

  prepro_test.append(s)

for i in range(len(text)):
  books["Description"][i] = prepro_test[i]

books.head()

tfidf = TfidfVectorizer(stop_words="english")

# fit and transform the text data`
tfidf_matrix = tfidf.fit_transform(books["Description"])

# print(tfidf_matrix)

# compute the cosine similarity matrix
cosine_sim = cosine_similarity(tfidf_matrix, tfidf_matrix)

book_id_to_name = {}

for i in range(len(users['Name_ID'])):
  if users['Name_ID'][i] not in book_id_to_name.keys():
    book_id_to_name[users['Name_ID'][i]] = users['Name'][i]

# print(book_id_to_name)

user_book_to_books_id = {}
books_id = {}

for i in range(len(books["Name"])):
  if books["Name"][i] not in books_id.keys():
    books_id[books["Name"][i]] = i

for i in range(len(users["Name_ID"])):
  if users["Name_ID"][i] not in user_book_to_books_id.keys():
    user_book_to_books_id[users["Name_ID"][i]] = books_id[users["Name"][i]]

# print(user_book_to_books_id)

book_id_user_books_id = {}
for i in user_book_to_books_id.keys():
  book_id_user_books_id[user_book_to_books_id[i]] = i

# print(user_book_to_books_id[11057])
# print(book_id_user_books_id)

def get_recommendations(book_id, cosine_sim=cosine_sim, books=books):

  # get the cosine similarity scores of the book with all other books
  sim_scores = list(enumerate(cosine_sim[book_id]))
  # print(sim_scores)

  # sort the books based on the cosine similarity scores
  sim_scores = sorted(sim_scores, key=lambda x: x[1], reverse=True)

  # get the top 5 most similar books
  sim_scores = sim_scores[1:6]

  return sim_scores

# userid = 20
def find_already_read_books(userid):
  already_read_books_n = []
  already_read_books = []
  ratings = []
  for i in range(len(users["ID"])):
    if users["New_ID"][i]==userid:         
      # if users["Rating"][i]>=3:   
      ratings.append(users["Rating"][i])                      #will find similar books to only those previously read books which are not disliked by the user
      already_read_books_n.append((user_book_to_books_id[users["Name_ID"][i]], users["Rating"][i]))
  
  minrating = min(ratings)
  # print(minrating)
  maxrating = max(ratings)
  # print(maxrating)
  avg = math.floor((minrating + maxrating)/2)
  # print(avg)
  # print(already_read_books_n)

  for i in range(len(already_read_books_n)):
    if already_read_books_n[i][1] >= avg:
      already_read_books.append(already_read_books_n[i][0])

  # print(already_read_books)
  return already_read_books

def get_content_recommendations(userid):
  all_recomm_books = []
  already_read_books = find_already_read_books(userid)
  # print(already_read_books)
  # for i in already_read_books:
  #   print(book_id_to_name[book_id_user_books_id[i]])
  books = []
  for i in range(len(already_read_books)):
    sim_scores = get_recommendations(already_read_books[i])

    for i in sim_scores:
      if i not in all_recomm_books and i[0] not in already_read_books and i[0] not in books:
        all_recomm_books.append(i)
        books.append(i[0])

  all_recomm_books = sorted(all_recomm_books, key=lambda x: x[1], reverse=True)

  # print(all_recomm_books)

  final_recomm_books = [i[0] for i in all_recomm_books[:10]]

  # print("Recommended books using Content based Filtering are: -\n")
  # for i in final_recomm_books:
  #   print(book_id_to_name[book_id_user_books_id[i]])
  
  return all_recomm_books, final_recomm_books

userid = 31
print(get_content_recommendations(userid)[1])

ffile = open("data/cf_ratings_matrix","rb")
cf_ratings_mat = pickle.load(ffile)
ffile.close()

for i in range(10):
  print(cf_ratings_mat[i])

def min_max_rating(userid):
  minrating = min(cf_ratings_mat[userid])
  maxrating = max(cf_ratings_mat[userid])
  return minrating, maxrating

def user_accuracy(userid):
  ratings_of_recomm_books = {}
  all_recomm_books = get_content_recommendations(userid)[0]

  for i in range(len(all_recomm_books)):
    bookid = all_recomm_books[i][0]
    users_bookid = book_id_user_books_id[bookid]
    rating = cf_ratings_mat[userid-1][users_bookid-1]
    ratings_of_recomm_books[users_bookid] = rating
  
  minrating, maxrating = min_max_rating(userid-1)
  user_avg_rating = (minrating+maxrating)/2

  relcount = 0        #no of relevant books 
  nonrelcount = 0     #no of non-relevant books 

  for i in ratings_of_recomm_books.values():
    if i>=user_avg_rating:
      relcount+=1
    else:
      nonrelcount+=1

  tn = 0
  fn = 0

  for i in range(11057):
    if user_book_to_books_id[i+1] not in all_recomm_books[:][0] and cf_ratings_mat[userid-1][i]<user_avg_rating:
      tn+=1
    elif user_book_to_books_id[i+1] not in all_recomm_books[:][0] and cf_ratings_mat[userid-1][i]>=user_avg_rating:
      fn+=1   
  accuracy = (relcount + tn)/(relcount + tn + nonrelcount + fn)
  return accuracy

accuracy_for_all_users = []
# for i in range(1,3535):
#   print(i)
#   accuracy_for_all_users.append(user_accuracy(i))

# sum_acc = sum(accuracy_for_all_users)
# avg_accuracy = sum_acc/len(accuracy_for_all_users)
# print(accuracy_for_all_users[0])
# print(avg_accuracy)

# file = open("/content/drive/MyDrive/content_based/cb_users_accuracy","wb")
# pickle.dump(accuracy_for_all_users, file)
# file.close()

ffile = open("data/cb_users_accuracy","rb")
accuracy_for_all_users = pickle.load(ffile)
ffile.close()

sum_acc = sum(accuracy_for_all_users)
avg_accuracy = sum_acc/len(accuracy_for_all_users)
# print(avg_accuracy)

def printcfbooks(cf_books):
  cf_book_list = []
  print("\nRecommended books using Collaborative based Filtering are: -\n")
  for i in range(10):
    # print(book_id_to_name[book_id_user_books_id[cf_books[i]]])
    cf_book_list.append(book_id_to_name[book_id_user_books_id[cf_books[i]]])

  return cf_book_list



def printcbbooks(cb_books):
  print("\nRecommended books using Content based Filtering are: -\n")
  cb_book_list = []
  for i in cb_books:

    # print(book_id_to_name[book_id_user_books_id[i]])
    cb_book_list.append(book_id_to_name[book_id_user_books_id[i]])
  return cb_book_list

def cf_recomm(userid):
  cf_recomm_all = []
  minrating, maxrating = min_max_rating(userid-1)
  avg_rating = (minrating + maxrating)/2
  already_read_books = find_already_read_books(userid)

  for i in range(len(cf_ratings_mat[userid-1])):
    if cf_ratings_mat[userid-1][i] >= avg_rating and user_book_to_books_id[i+1] not in already_read_books:
      cf_recomm_all.append([user_book_to_books_id[i+1], cf_ratings_mat[userid-1][i]])

  cf_recomm_all = sorted(cf_recomm_all, key=lambda x: x[1], reverse=True)  
  cf_recomm_books = [i[0] for i in cf_recomm_all[:]]

  return cf_recomm_books

print(cf_recomm(2))

def get_hybrid_recommendations(userid):

  cf_recommendations = cf_recomm(userid)
  # printcfbooks(cf_recommendations)

  cb_recommendations = get_content_recommendations(userid)[1]
  # printcbbooks(cb_recommendations)

  book_recommendations = []
  for i in cb_recommendations:
    if i in cf_recommendations:
      book_recommendations.append(i)

  # print("Same Recommended books are: -\n")
  # for i in book_recommendations:
  #   print(book_id_to_name[book_id_user_books_id[i]])

  if len(book_recommendations) < 10:
    num = 10-len(book_recommendations)

  #   for i in cb_recommendations:

  #     if i not in book_recommendations:

  #       book_recommendations.append(cb)


    cf_ratio = math.floor(num*(1/3))
    cb_ratio = num-cf_ratio

    if len(cb_recommendations)-len(book_recommendations) < cb_ratio:
      cf_ratio = cf_ratio + cb_ratio-len(cb_recommendations) + len(book_recommendations)
      cb_ratio = len(cb_recommendations) - len(book_recommendations)

    j = cb_ratio
    k=0
    while j>0:
      if cb_recommendations[k] not in book_recommendations:
        book_recommendations.append(cb_recommendations[k])
        j-=1
      k+=1

    i=cf_ratio
    k=0
    while i>0:
      if cf_recommendations[k] not in book_recommendations:
        book_recommendations.append(cf_recommendations[k])
        i-=1
      k+=1
    
   

  # print(book_recommendations)
  llist = []
  print(f"\nRecommended books using Hybird Filtering for id {userid} are: -\n")
  for i in book_recommendations:
    # print(book_id_to_name[book_id_user_books_id[i]])
    llist.append(book_id_to_name[book_id_user_books_id[i]])

  return llist


def popularity_based():
  m = 50 # minimum votes required to be listed
  k = books['Rating'].mean()
  popularity_ratings = {}
  for i in range(len(books)):
    r = books['Rating'][i]
    v = books['CountsOfReview'][i]
    wr = (r*v + k*m) / (v+m)
    popularity_ratings[i] = wr

  sorted_dict = dict(sorted(popularity_ratings.items(), key=lambda x:x[1],reverse=True))
  out  = dict(itertools.islice(sorted_dict.items(),10))

  booklist = []
  for i in out.keys():
    booklist.append(books['Name'][i])
    print(books['Name'][i])

  return booklist

def find_fev_books(userid):
  
  already_read_books = []
  fev_book_names = []
  ratings = []

  for i in range(len(users["ID"])):

    if users["New_ID"][i]==userid:         

      ratings.append(users["Rating"][i])  #will find similar books to only those previously read books which are not disliked by the user
      already_read_books.append((user_book_to_books_id[users["Name_ID"][i]], users["Rating"][i]))
  
  max_rat = max(ratings)

  fev_books = []

  for i in already_read_books:

    if i[1] == max_rat and i[0] not in fev_books:

      fev_books.append(i[0])
      fev_book_names.append(book_id_to_name[book_id_user_books_id[i[0]]])
  
  return fev_books[:3], fev_book_names[:3]

def sortt(lst):

  return sorted(lst, key=lambda x: x[1], reverse=True)

def fev_recc(userid):

  all_recomm_books = []

  fev_books, fev_book_names = find_fev_books(userid)
  
  for i in range(len(fev_books)):

    new_books = []
    books = []

    sim_scores = get_recommendations(fev_books[i])

    for i in sim_scores:

      if i not in new_books and i[0] not in fev_books and i[0] not in books:

        new_books.append(i)
        books.append(i[0])
    
    all_recomm_books.append(new_books)
  
  sorted_books = []

  for i in all_recomm_books:

    sorted_books.append(sortt(i))

  # all_recomm_books = sorted(all_recomm_books, key=lambda x: x[1], reverse=True)

  final_recomm_books = []

  for i in sorted_books:

    l = []

    for j in i:

      l.append(j[0])
    
    final_recomm_books.append(l)
  
  fev_recomm = []
  
  for i in final_recomm_books:

    l = []

    for j in i:

      l.append(book_id_to_name[book_id_user_books_id[j]])
    
    fev_recomm.append(l)
    
  return fev_recomm, fev_book_names

def get_recent_books():
  count = 0
  title = []
  for i in range(len(books["PublishYear"])):
    if books["PublishYear"][i]>=2018:
      title.append(books["Name"][i])
      count+=1

  return title
    

import streamlit as st

global_users = set(range(1,3534))


# Define function to check if user ID is valid (in this example, we just accept any non-empty input)
def is_valid_user_id(user_id):
    return bool(user_id)

def is_unique_user_id(user_id):
    return user_id not in global_users

# Define function to store user ID (in this example, we just print it)
def store_user_id(user_id):
    global_users.add(int(user_id))
    print(f"Storing user ID: {user_id}")

# Define function to show recommendation page (in this example, we just print a message)
# def show_recommendation_page(user_id):
#     recommender_page(user_id)
    # st.write("Welcome to recommendation page!")
    # print(f"Showing recommendation page for user ID: {user_id}")

def get_user_inputs():
    # genre_input = st.text_input("What are your favorite book genres? (comma separated)", "Mystery, Thriller, Romance")
    # liked_books_input = st.text_input("What are some books that you like? (comma separated)", "Gone Girl, The Girl on the Train, The Fault in Our Stars")
    model_input = st.selectbox("Select a recommendation model", ("Collaborative Filtering", "Content-based Filtering", "Hybrid Model", "Popularity-based"))
    return model_input

def get_new_user_inputs():
    # genre_input = st.text_input("What are your favorite book genres? (comma separated)", "Mystery, Thriller, Romance")
    # liked_books_input = st.text_input("What are some books that you like? (comma separated)", "Gone Girl, The Girl on the Train, The Fault in Our Stars")
    model_input = st.selectbox("Select a recommendation model", ("-","Popularity-based"))
    return model_input

# def get_fav_user_inputs():
#     # genre_input = st.text_input("What are your favorite book genres? (comma separated)", "Mystery, Thriller, Romance")
#     # liked_books_input = st.text_input("What are some books that you like? (comma separated)", "Gone Girl, The Girl on the Train, The Fault in Our Stars")
#     getfavbooks = st.selectbox("Show books similar to your previously liked books", ("Yes","No"))
#     return getfavbooks

# function to recommend books based on user inputs
def recommend_books(user_id, model):
  recommended_books = []
    # all the model code goes here
  if model == "Collaborative Filtering":
    recommended_books = printcfbooks(cf_recomm(user_id))
  elif model == "Hybrid Model":
    recommended_books = get_hybrid_recommendations(user_id)
  elif model == "Content-based Filtering":
    recommended_books = printcbbooks(get_content_recommendations(user_id)[1])
  elif model == "Popularity-based":
    recommended_books = popularity_based()
  elif model == "-":
    recommended_books = popularity_based()
    # recommended_books = ['The Silent Patient', 'The Nightingale', 'Where the Crawdads Sing']
  return recommended_books

def show_fav_books(user_id):
  fav_books = fev_recc(user_id)
  return fav_books

def recommender_page(user_id):
    st.title("Book Recommender System")
    st.write("Welcome to our book recommender system! Please fill in your details below to get personalized book recommendations.")
    model_input = get_user_inputs()
    if st.button("Recommend Books"):
      # st.write(f'Your liked books are {liked_books_input}')
      st.write(f"<h1 style='font-size:26px'>Your chosen model is {model_input}</h1>",unsafe_allow_html=True)
      st.write(f"Based on your inputs, we recommend the following books using the {model_input} model:")
      recommended_books = recommend_books(user_id, model_input)
      for i, book in enumerate(recommended_books,1):
        st.write(f'*{i}. {book}*')
    # ans = get_fav_user_inputs()
    st.write("\n")
    st.write("<h1 style='font-size:26px'>Books similar to your favorite books</h1>",unsafe_allow_html=True)
    fav_books, fav_book_names = show_fav_books(user_id)
    for i in range(len(fav_books)):
      st.write('\n')
      st.write(f'*{fav_book_names[i]} ')
      for j, book in enumerate(fav_books[i],1):
        st.write(f'*{j}. {book}*')

    st.write("\n")
    st.write("<h1 style='font-size:26px'>Recently Published Books</h1>",unsafe_allow_html=True)
    new_books = get_recent_books()
    for i, book in enumerate(new_books,1):
      st.write(f'*{i}. {book}*')
        
       
       

def new_user_recommender_page(user_id):
    st.title("Book Recommender System")
    st.write("Welcome to our book recommender system! Please fill in your details below to get personalized book recommendations.")
    model_input = get_new_user_inputs()
    if st.button("Recommend Books"):
        # st.write(f'Your liked books are {liked_books_input}')
        st.write(f'Your chosen model is {model_input}')
        # genres = [genre.strip() for genre in genre_input.split(',')]
        # liked_books = [book.strip() for book in liked_books_input.split(',')]
        st.write(f"Based on your inputs, we recommend the following books using the {model_input} model:")
        recommended_books = recommend_books(user_id, model_input)
        for i, book in enumerate(recommended_books,1):
                st.write(f'*{i}. {book}*')
  
    st.write("\n")
    st.write("<h1 style='font-size:26px'>Recently Published Books</h1>",unsafe_allow_html=True)
    new_books = get_recent_books()
    for i, book in enumerate(new_books,1):
      st.write(f'*{i}. {book}*')

# Ask if user is an existing user
def main():
    existing_user = st.radio("Are you an existing user?", ("Yes", "No"))

    if existing_user == "Yes":
        # Ask for user ID
        user_id_str = st.text_input("Please enter your user ID:")
        user_id = int(user_id_str)
        if is_valid_user_id(user_id) and not is_unique_user_id(int(user_id)):
            # User ID is valid, show recommendation page
            recommender_page(user_id)
        else:
            # User ID is not valid, show error message
            st.error("Please enter a valid user ID.")
    else:
        # Ask to set user ID
        user_id = st.text_input("Please set your user ID:")
        if is_valid_user_id(user_id) and is_unique_user_id(int(user_id)):
            # User ID is valid, store it and show recommendation page
            store_user_id(user_id)
            new_user_recommender_page(user_id)
        else:
            # User ID is not valid, show error message
            st.error("Please enter a valid user ID.")

if __name__ == "__main__":
    main()

print(get_hybrid_recommendations(31))
print(get_hybrid_recommendations(15))
print(printcfbooks(cf_recomm(2)))
